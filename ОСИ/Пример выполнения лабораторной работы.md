#оси 
## Условия
Написать программу определения типа файла, указанного при запросе. Предусмотреть обработку сигнала прерывания от клавиатуры. При поступлении 3 сигналов прерывания вывести все файлы текущего каталога, написанные на Си.

- `ls -la`  - вывести все файлы (даже те, имена которых начинаются с точки)
- `ls -la -d <имя_файла>`  - вывести информацию о файле в таком формате:
	- `xrw-r--r-- uid размер имя_файла`, где x - формат файла (d, p, b, c, l, s)
	- `-d` - не позволяем залезать внутрь директории, если нам её передали

## Алгоритм решения задачи
### Программа-процесс
- Указание метода обработки сигнала ([[sigaction]])
- Запрос на имя файла
- Проверка введённых данных
- Создание межроцессного канала ([[pipe]])
- Создание процесса-сына([[fork]])
- Ожидание завершения процесса сына
- Считывание результатов сына
- Обрезка результата сына и вывод
- Конец

### Программа-обработчик
```C
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/wait.h>

int count = 0; // счётчик прерываний
void func() {
	int p1[2], p2[2], s;
	count++;
	if (count == 3) {
		pipe(p1);
		if (fork() == 0) {
			close(p1[0]);
			dup2(p1[1], 1);
			close(p1[1]);
			system("file *");
			_exit(1);
		}
		else {
			wait(&s);
			pipe(p2);
			if (fork() == 0) {
				dup2(p2[1], 1);
				dup2(p1[0], 0);
				system("grep \"C program\"");
				_exit(2);
			}
			else {
				wait(0);
				dup2(p2[0], 0);
				close(p1[0]);
				close(p1[1]);
				close(p2[0]);
				close(p2[1]);
				system("cut -d : -f 1");
				_exit(0);
			}
		}
	}
}

void main() {
	int fd, p[2];
	char name[256], buf[80];
	memset(name, 0, 256);
	memset(buf, 0, 80);
	struct sigaction arg;
	arg.sa_handler = func;
	sigprocmask(0, 0, &arg.sa_mask);
	arg.sa_flags = 0;
	sigaction(SIGINT, &arg, 0);
	while(1) {
		printf("Введите имя файла:");
		scanf("%s", name); // read(0, name, 256);
		if (!access(name, F_OK)) {
		break;
		}
		pipe(p); // добавили пайп на чтение в ячейку 3 и пайп на запись в ячейку 4
		if (fork() == 0) {
			close(p[0]);
			close(1);
			dup(p[1]);
			execl("/bin/ls", "ls", "-la", "-d", name, NULL);
		} else {
			wait(0);
			close(p[1]);
			while(1) {
				if (read(p[0], buf, 80) != 0) {
					if (buf[0] == '-') {printf("Файл %s обычный");}
					if (buf[0] == 'd') {printf("фАЙЛ %S - директория");}
					...
				}
			}
		}
	}
}
```

### Обработка прерываний
Если мы напишем в `file *`, то нам выдаст такую картину:
```
a.txt: ASCII text file
a.exe: 64-bit Binary executable file..
a.cpp: c program text file ...
b.c: c program text UTF-8 file
```

Хотим уметь определять C файлы. Придумали, что можно смотреть на начало описания и искать "C source" или "C program". На shell напишем так:
`file * | grep "C program" | cut -f 1 -d :` - ищем файлы, где в описании есть "C program" и вырезаем название

Для этого нам нужны два сына. Один будет искать "C program", а второй будет обрезать название. Теперь напишем его (потом перенесу в func в основной программе):
```C
void func() {
	int p1[2], p2[2], s;
	count++;
	if (count == 3) {
		pipe(p1);
		if (fork() == 0) {
			close(p1[0]);
			dup2(p1[1], 1);
			close(p1[1]);
			system("file *");
			_exit(1);
		}
		else {
			wait(&s);
			pipe(p2);
			if (fork() == 0) {
				dup2(p2[1], 1);
				dup2(p1[0], 0);
				system("grep \"C program\"");
				_exit(2);
			}
			else {
				wait(0);
				dup2(p2[0], 0);
				close(p1[0]);
				close(p1[1]);
				close(p2[0]);
				close(p2[1]);
				system("cut -d : -f 1");
				_exit(0);
			}
		}
	}
}
```