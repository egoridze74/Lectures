#оси 
Создаёт файл в оперативной памяти, который пользователь обычно называет **"межпроцессным каналом"** (коммуникационный канал, программный канал) и открывает его и на чтение, и на запись (создаёт 2 дескриптора).

Объём канала указан в `limits.h` (вроде бы равен 1 Мб).
```
int pipe(int fd[]);
```

Возвращает 2 пользовательских дескриптора:
- `fd[0]` - чтение
- `fd[1]` - запись

Прогоним сценарий с таблицей открытых дескрипторов:
- $0 \ /dev/tty_{чт}$
- $1 \ /dev/tty_{зап}$
- $2 \ /dev/tty_{зап \ ошибок}$
- $3 \ pipe_{чт}$
- $4 \ pipe_{зап}$

Дальше можно вызвать, например, [[fork]], тогда создадутся 2 процесса с одинаковыми таблицами открытых дескрипторов.

В нашем случае получится, что:
$fd[0] = 3$
$fd[1] = 4$

Синхронизация обмена через межпроцессорный канал осуществляется так:
**Отец-сын:**
- Если процесс-отец пишет в канал, а процесс сын не читает информацию из канала, может случиться так, что процесс-отец будет ждать освобождения места в канале;
- Если процесс-отец пытается записать данные в канал, а процесс-сын перекрыл канал для чтения, то процесс-отец получает сигнал `SIGPIPE 13`, что означает "разорванный канал";
**Сын-отец:**
- Если процесс-сын читает данные из канала, а процесс-отец ничего не пишет, то процесс-сын будет ждать появления данных в канале
- Если процесс-отец перекрыл канал на запись (`close(fd[1])`), то в какой-то момент при чтении сын получит код ответа 0, что означает признак конца файла.

## Пример программы
Хотим сделать программу по поиску всех текстовых файлов.
```c
file * //Анализирует файлы в текущей директории

//Получим:
a.c: C program text file
a.exe: 64-bit executable file
a.dat: ASCII text file
a.txt: UTF-8 text file
a : command script text file

file * | grep text //Анализирует файлы в текущей директории и оставляет только текстовые

//Получим:
a.c: C program text file
a.dat: ASCII text file
a.txt: UTF-8 text file
a : command script text file

//Хотим вырезать что-то (с помощью утилит awk, cut или sed):
       p1          p2 //каналы pipe1 и pipe2
file * | grep text | cut -f 1 -d ":"

Получим:
a.c
a.data
a.txt
a
```

Приступим к написанию самой программы:
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
	int p1[2], p2[2], fd;
	char buf[80];
	pipe(p1);
	pipe(p2);
	if (fork() == 0) {
		dup2(p1[1], 1); //у сына вывод из пайпа дублируется в системный вывод
		system("file *");
		exit(0); //сын погибает, все его дескрипторы закрываются
	}
	else {
		wait(0);
		if (fork() == 0) {
			dup2(p1[0], 0); //меняем стандартное чтение на чтение из канала 1
			dup2(p2[1], 1); //меняем стандартное вывод на вывод из канала 2
			close(p2[1]); //закрыли 6 дескриптор
			close(p2[0]); //закрыли 5 дескриптор
			system("grep text"); 
			//утилита grep возьмёт данные стандартного ввода и результат напишет
			//в стандартный вывод
			exit(0);
		}
		else {
			wait(0);
			dup2(p2[0], 0); //меняем стандартное чтение на чтение из канала 2
			system("cut -f 1 -d ':'"); //результат выполнения на монитор
			exit(0); //убили отца
		}
	}
}
```