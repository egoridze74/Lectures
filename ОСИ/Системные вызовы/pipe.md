#оси 
Создаёт файл в оперативной памяти, который пользователь обычно называет **"межпроцессным каналом"** (коммуникационный канал, программный канал) и открывает его и на чтение, и на запись (создаёт 2 дескриптора).

Объём канала указан в `limits.h` (вроде бы равен 1 Мб).
```
int pipe(int fd[]);
```

Возвращает 2 пользовательских дескриптора:
- `fd[0]` - чтение
- `fd[1]` - запись

Прогоним сценарий с таблицей открытых дескрипторов:
- $0 \ /dev/tty_{чт}$
- $1 \ /dev/tty_{зап}$
- $2 \ /dev/tty_{зап \ ошибок}$
- $3 \ pipe_{чт}$
- $4 \ pipe_{зап}$

Дальше можно вызвать, например, [[fork]], тогда создадутся 2 процесса с одинаковыми таблицами открытых дескрипторов.

В нашем случае получится, что:
$fd[0] = 3$
$fd[1] = 4$

Синхронизация обмена через межпроцессорный канал осуществляется так:
**Отец-сын:**
- Если процесс-отец пишет в канал, а процесс сын не читает информацию из канала, может случиться так, что процесс-отец будет ждать освобождения места в канале;
- Если процесс-отец пытается записать данные в канал, а процесс-сын перекрыл канал для чтения, то процесс-отец получает сигнал `SIGPIPE 13`, что означает "разорванный канал";
**Сын-отец:**
- Если процесс-сын читает данные из канала, а процесс-отец ничего не пишет, то процесс-сын будет ждать появления данных в канале
- Если процесс-отец перекрыл канал на запись (`close(fd[1])`), то в какой-то момент при чтении сын получит код ответа 0, что означает признак конца файла.