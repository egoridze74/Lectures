#оси 
**Процесс** - программа на стадии выполнения.

Рассмотрим системные вызовы, которые управляют процессами.

## system
```
int system(char *com);
```
Запускает один процесс в рамках другого процесса.
В случае успеха возвращает 0, в случае неудачи -1. \*com - адрес команды, которую хотим выполнить.

Пример:
```
... - код программы
system("ls -l");
...
system("cp a.c b.c");
...
system("./a.exe");
```
В данном случае выполняется наша программа, затем выводится **полная** информация о файлах в нашем каталоге, далее выполняется наша программа. В какой-то момент мы копируем содержимое файла a.c в файл b.c. Последний вызов запускает какую-то программу a.exe из этой папки.

## Семейство exec
```
exec()
execvp()
execv()
execl()
```
Они все различаются только аргументами и возвращаемыми значениями, поэтому рассмотрим какой-то один.
```
int execl(char *path, char *arg0, char *arg1, ..., char *argn, NULL);
```
Убивает текущий процесс и запускает другой. В случае успеха возвращает 0, в случае неудачи -1.

Пример:
```
...
execl("/bin/ls", "ls", "-l", 0);
#arg0 = "ls", arg1 = "-l"
#вместо 0 лучше писать NULL, а то получишь предупреждение
execl("/bin/cp", "cp", "a.c", "b.c", NULL);

execl(".../a.exe");
execl("./a.exe", "a.exe", NULL);
```
Программа, которая шла, прерывается, и выполняется то, что вызываем в execl.

## Немного про файловую систему
![[Pasted image 20250909152550.png|500]]

## fork
```
int fork();
либо forkpid();
```
Создаёт новый процесс, который является абсолютным клоном текущего процесса. Все переменные такие же, все открытые файлы, все используемые ресурсы. Возвращает 0 для процесса потомка. 
```
int p;
p = fork();
if (p > 0) {
отец
}
else
```

форк возвдращает 0 для процесса ну давайте потомка ну для процесса поптомка, хотя потомок это много букв, процессор давайте так форк это будет родитель, осздаваемый процесс - ребененок, создавателя процесса можно назвать отец или мать а процесс порождаемый пусть дочь, а нет много букв пусть будет дочь. Бит сына - бит, процесс ид процесс идентификатор с имя процесса, сын - число какое-то. Синтаксис следующий: if ... if(fork=0) {/*код процесса сына */} , иначе можно не писать елсе код отца дальше потому что мы привыкли к классике пусть будет else код процесса отца. Элсе можно не писать вот сделали вофрк, визуально это будет так будет форк, у вас появился процесс 1 и процесс 2 после форка два процесса, один - отец, другой мы с вами назвали сын. После форка они одновременно существуют. Каждый живет своей жизнью, но сын это точная копия, а после начинает от вас отклоняться. Вот допустим Ангелина любит арбузы, а дочь - дыня. Другой вид пищи потребляет. В соответвтсивии с этим Ангелина будет делать все чтобы росли Дыни, а у нее Арбузы в смысле оно. Вы понимаете что сын или там потомок может заниматься чем угодно, но это потом, а вначале все одинаковое. там регистры, файлы, но каждый своей жизнью живет. Классический вариант сейчас напишем. ЗНачит int p, отвел место в памяти. p = fork(); Только форк выполнили  а уже получили два процесса.  ЗДесь давайте if p > 0. это  унас давайте я не буду писать код процесса отца, просто напишу отец, так будет понятно. Вот отец. Так. ну давайте можно етсь такая конструкция else if, пусть будет else, так вот else скобочка if p = 0 это сын так else это авария. Никита: а вот у меня вопрос, вы когда делаете форк он делает поллную копию отца -Препод: нет, у него просто копия ресурсов никита: так значит у него те же самые ресурсы. Мы создали сына, отец может ждать когда он это сделает, а может свое что-то делать. Он не бездействует. Вы обычно чтобы не обременять вы замедление работы системы. Поэтому вы обычно когда создаете от отца, отец убивает сына точнее берет результаты и убивает сына уже продолжает деятельность. Он может другого сына создать и убить. Nikita: Он сам вызывает команду убить сына. Prepod:   c помощью какого системного средства вы убиваете сына? Kill - не подходит. Exit - вот он подоходит **У;"№;(необъяснимая игра слов)** Каким образом еще можно убить сына - с помощью сигнали - это версия прерывания. Есть утилита  kill, а сигнал - девятый. Значит это сигнал опция девятый сигнал из командной строки можно послать и из программы. Придумаем Ангелине короткое имя