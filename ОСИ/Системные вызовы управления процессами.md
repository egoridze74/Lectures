#оси 
## Про системные вызовы
Каждый процессор характеризуется своим количеством команд. С помощью команд организуется всё управление системой.

Так и операционные системы управляются своими **системными вызовами**.
Например, есть:
- библиотечная функция printf() - с буферизацией и через write
- есть системный вызов write() - чисто без буферизации

**Системные вызовы** - набор функций, код которых находится в ядре ОС.

## Процессы
**Процесс** - программа на стадии выполнения.

Рассмотрим системные вызовы, которые управляют процессами.

## system
```
int system(char *com);
```
Запускает один процесс в рамках другого процесса.
В случае успеха возвращает 0, в случае неудачи -1. \*com - адрес команды, которую хотим выполнить.

### Пример:
```
... - код программы
system("ls -l");
...
system("cp a.c b.c");
...
system("./a.exe");
```
В данном случае выполняется наша программа, затем выводится **полная** информация о файлах в нашем каталоге, далее выполняется наша программа. В какой-то момент мы копируем содержимое файла a.c в файл b.c. Последний вызов запускает какую-то программу a.exe из этой папки.

## Семейство exec
```
exec()
execvp()
execv()
execl()
```
Они все различаются только аргументами и возвращаемыми значениями, поэтому рассмотрим какой-то один.
```
int execl(char *path, char *arg0, char *arg1, ..., char *argn, NULL);
```
Убивает текущий процесс и запускает другой. В случае успеха возвращает 0, в случае неудачи -1.

### Пример:
```
...
execl("/bin/ls", "ls", "-l", 0);
#arg0 = "ls", arg1 = "-l"
#вместо 0 лучше писать NULL, а то получишь предупреждение
execl("/bin/cp", "cp", "a.c", "b.c", NULL);

execl(".../a.exe");
execl("./a.exe", "a.exe", NULL);
```
Программа, которая шла, прерывается, и выполняется то, что вызываем в execl.

## Немного про файловую систему
![[Pasted image 20250909152550.png|500]]

## fork
```
int fork();
либо forkpid();
```
Создаёт новый процесс, который является абсолютным клоном текущего процесса. Все переменные такие же, все открытые файлы, все используемые ресурсы. Возвращает 0 для процесса потомка.
```
...
if (fork() == 0) 
	{/* код процесса сына */}
else 
	{/* код процесса сына */}
```

```
int main(int argc, void *argv[])
int p;
p = fork();
if (p > 0) 
	{/* отец */} 
else {
	if (p == 0) 
		{/* сын */}
	else 
		{/* авария */}
}
```

форк возвдращает 0 для процесса ну давайте потомка ну для процесса поптомка, хотя потомок это много букв, процессор давайте так форк это будет родитель, осздаваемый процесс - ребененок, создавателя процесса можно назвать отец или мать а процесс порождаемый пусть дочь, а нет много букв пусть будет дочь. Бит сына - бит, процесс ид процесс идентификатор с имя процесса, сын - число какое-то. Синтаксис следующий: if ... if(fork=0) {/*код процесса сына */} , иначе можно не писать елсе код отца дальше потому что мы привыкли к классике пусть будет else код процесса отца. Элсе можно не писать вот сделали вофрк, визуально это будет так будет форк, у вас появился процесс 1 и процесс 2 после форка два процесса, один - отец, другой мы с вами назвали сын. После форка они одновременно существуют. Каждый живет своей жизнью, но сын это точная копия, а после начинает от вас отклоняться. Вот допустим Ангелина любит арбузы, а дочь - дыня. Другой вид пищи потребляет. В соответвтсивии с этим Ангелина будет делать все чтобы росли Дыни, а у нее Арбузы в смысле оно. Вы понимаете что сын или там потомок может заниматься чем угодно, но это потом, а вначале все одинаковое. там регистры, файлы, но каждый своей жизнью живет. Классический вариант сейчас напишем. ЗНачит int p, отвел место в памяти. p = fork(); Только форк выполнили  а уже получили два процесса.  ЗДесь давайте if p > 0. это  унас давайте я не буду писать код процесса отца, просто напишу отец, так будет понятно. Вот отец. Так. ну давайте можно етсь такая конструкция else if, пусть будет else, так вот else скобочка if p = 0 это сын так else это авария. Никита: а вот у меня вопрос, вы когда делаете форк он делает поллную копию отца -Препод: нет, у него просто копия ресурсов никита: так значит у него те же самые ресурсы. Мы создали сына, отец может ждать когда он это сделает, а может свое что-то делать. Он не бездействует. Вы обычно чтобы не обременять вы замедление работы системы. Поэтому вы обычно когда создаете от отца, отец убивает сына точнее берет результаты и убивает сына уже продолжает деятельность. Он может другого сына создать и убить. Nikita: Он сам вызывает команду убить сына. Prepod:   c помощью какого системного средства вы убиваете сына? Kill - не подходит. Exit - вот он подоходит **У;"№;(необъяснимая игра слов)** Каким образом еще можно убить сына - с помощью сигнали - это версия прерывания. Есть утилита  kill, а сигнал - девятый. Значит это сигнал опция девятый сигнал из командной строки можно послать и из программы. Придумаем Ангелине короткое имя

## exit и \_exit
```
int _exit(int arg);
```
Функционал - убить процесс, в рамках которого был запущен этот вызов, а также закрыть все файлы, открытые в данном процессе. В случае успеха возвращает 0, в случае неудачи -1 (неудачи почти никогда не бывает). 

Аргумент - число, вставляемое пользователем для того, чтобы другие процессы могли понять причину гибели данного процесса.

Вызов exit без подчёркивания выталкивает буфер.

## wait и waitpid
```
int wait(int *s); //waitpid()
```
Функция - ожидание процесса. Приостанавливает выполнение родительского процесса до тех пор, пока не прекратит выполнение один из его дочерних процессов. В случае успеха возвращает 0, в случае неуспеха -1.

Вызов waitpid() ждёт определённый процесс (в функцию передаётся id нужного процесса), а wait() - любой.

Возвращает причину гибели процесса-сына в виде идентификатора (числа).

### Пример:
```
int s;
if (fork() == 0)
{ /* процесс сын */
...
}
wait(&s);
```
Здесь wait используется для того, чтобы дождаться окончания процесса-сына, после чего продолжит свою работу процесс-отец.

Битовое число s представляется так:
![[Pasted image 20250916151715.png|500]]

## Немного про сигналы
Некоторые сигналы убивают, другие лишь приостанавливают.
ctrl + c - SIGINT - убить процесс (0 в 7-ом бите)
ctrl + z - SIGTSTP - остановить процесс (1 в 7-ом бите)

> “Я хотел бы узнать, почему умер у меня сын. У вас есть версии какие-то?"

Истратов Анатолий Юрьевич

Пример с  exit:
$0100000000 = 512 = 2^9$
$1010000000 = 2^{10} + 2^{8} = 1256$ - по этому адресу запишется это число

## Про открытие файлов
При создании любого процесса ОС автоматически открывает для него 3 файла:
0. $/dev/tty_{чт}$ - файл стандартного чтения
1. $/dev/tty_{зап}$ - файл стандартного вывода
2. $/dev/tty_{зап}$ - файл стандартного протокола

Таблица, которую мы сейчас начали - **таблица пользовательских интерфейсов**. В ней хранится инфа об открытых дескрипторах (пользовательских интерфейсах), и она обновляется с каждым открытием файла.

Примеры вызовов, которые обращаются к таблице:
- printf(); - обратится к дескриптору с #1 в таблице
- puts();
- perror();
- scanf(); - обратится к дескриптору с #0 в таблице
Пользовательский дескриптор - файловый дескриптор
Запись в таблице = дескриптор

## open
```
int open(char *path, int flag);
```
Предназначен для открытия или создания файлов.
- path - имя файла (неполное имя = ищем в текущей директории)
- flag - режим открытия файла
	Макросы режимов описаны в <fcntl.h>:
	- \# define O_RDONLY 0
	- \# define O_WDONLY 1
	- \# define O_RDWR 2
	- ...
	- \# define O_CREAT 4

В случае успеха возвращает номер первой свободной записи из таблицы пользовательских дескрипторов открытых файлов процесса. В случае неудачи -1. -1 возвращается только если файла в директории нет, либо нет прав для открытия с заданным флагом.

### Пример:
```
open("a.txt", 0); // Пусть файл есть в текущем каталоге и у нас есть права
```
В этом случае open вернёт 3, так как запишется в 3 строку таблицы пользовательских дескрипторов.

```
close(0);
open("a.txt", 0); // Пусть файл есть в текущем каталоге и у нас есть права
```
В этом случае open вернёт 0, так как запишется в 0 строку таблицы пользовательских дескрипторов. Причём, теперь scanf() будет читать ввод не с клавиатуры, а из этого файла.

## creat
```
int creat(chr *path, int mode);
```
Этот системный вызов возвращает номер дескриптора.
Аргументы:
- path - путь к файлу
- mode - права доступа

Системный вызов creat не только создаёт файл, но и открывает его на запись

### Биты прав доступа (mode):
Каждая группа из 3 битов соответствует правам: rwx (rwad, write, execution)
- 8-6 - Владелец (User)
- 5-3 - Группа (Group)
- 2-0 - Прочие (others)

Например, возьмём 
1. creat("a.txt", 432);
	$432_{10} = 0660_{8}$, тогда права доступа будут:
	- 110 - user может читать и писать
	- 110 - группа может читать и писать
	- 000 - прочие ничего не могут
	У файла может быть только один владелец и одна группа.
2. creat("a.txt", 5);
	Дали возможность другим пользователям читать и исполнять файл, но себя лишили всех прав.
3. creat("a.txt", 054);
	Запрос вернёт -1, так как мы до этого сами лишили себя прав что-либо делать

Обновлённая таблица пользовательских дескрипторов:
0. $a.txt_{зап}$
1. $/dev/tty_{зап}$
2. $/dev/tty_{зап}$
3. $a.txt_{чт}$
4. $a.txt_{зап}$
5. $a.txt_{зап}$

