#оси #сигналы 
## Сигналы
**Сигнал** - программная версия аппаратного прерывания

Все сигналы хранятся в <signal.h> в виде:
```
#define SIGHUP 1 //сигнал посылается аппаратурой, когда теряется связь с управляющим терминалом
#define SIGINT 2 //сигнал посылается пользователем для убийства программы (Ctrl+C)
...
#define SIGKILL 9 //единственный, обработку которого нельзя отобрать у системы
...
#define SIGPIPE 13
...
#define SIGTSTP 19 //сигнал "стоп" посылается пользователем (Ctrl + Z). Отличие с SIGINT - останавливает вместо убийства процесса
...
#define SIG_DFL 0
```

Возможные реакции на сигнал:
- сигнал игнорируется - прописываем макрос SIG_IGN
- включается обработчик ОС - прописываем макрос SIG_DFL
- выполнить обработчик, реализованный пользователем

## Sigaction и макросы
В начале программы должен присутствовать sigaction, чтобы прописать, какой будет реакция на различные сигналы.
```
sigaction(nsig, SIG_IGN/SIG_DFL, Имя_функции)
```

Замечание: Функция с "Имя_функции" должна быть описана раньше, чем sigaction. Пример:
```
void func() {
	system("date")
}
int main() {
	int i; char a[500];
	struct sigaction new, old;
	struct sigaction {
		void sa_handler();
		sigset_t sa_mask();
		int sa_flags;
	}
}
```

Можно ещё объявить свой сигнал:
```
int signal(int nsig, Имя_функции);
```

В sigaction, в отличие от сигнала, поддерживается **сигнальная маска процесса**.
Сигнальная маска является одним из атрибутов дескриптора процесса в ОС UNIX и служит для определения процесса на какой-либо сигнал. Представляет собой битовую переменную, тип данных которой: `sigset_t`. Этот тип данных описан в `<signal.h>`. По сути своей это набор битов (условно говоря, из 48). Каждый бит отвечает за свой сигнал:
- 1 - SIGHUP
- 2 - SIGINT
- и т.д.
Если бит равен 0, то процесс не ждёт этого сигнала. При 1 наоборот.

При рождении процесс наследует сигнальную маску своего родителя.