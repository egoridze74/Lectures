#ЯПы 
Книжки для экза:
- Страуструп
- Мейерс
- Вильямс
- **Выравнивание в памяти** - например, структуры располагаются либо подряд, либо по чётности (каждые 16, 32 бита)
- Атрибуты:
	- К войду приписали $[[noreturn]]$ для оптимизации компилятора
	- К функциям приписали $[[noexcept]]$ - пишем вместо пустого throw
- Атомарные операции и типы данных - типы данных, которые гарантированно считаются или запишутся за один этап (одно обращение)
- С99 фичи - например, большие типы данных в 64 бита (long long)
- Строго типизированные enum'ы - определили размер и область видимости
- Копирование и запуск исключений
- decltype - имя типа (для шаблонов)
- default и delete теперь можно использовать в классах
- Новый тип данных - **универсальная ссылка** и **семантика перемещений**
- Внешние шаблоны
- Обновление цикла for (новый тип цикла for)
- Хвостовой тип возвращаемого значения (можно писать тип возвращаемого значения в конце)
- Делегирование конструктора - конструкторы можно использовать внутри класса
- Можно подтягивать родительские конструкторы детям
- Новый тип данных - список инициализации (можно инициализировать n переменных одного типа)
- **Лямбда-функции** (анонимные функторы)
- Локальные классы как аргументы шаблона
- Сужение типов (как его избежать)
- Нулевой указатель - тип данных nullptr. Его можно интерпретировать только как указатель, сравнивать с 0 нельзя
- Override и final
- POD - старые сишные группировочные типы данных
- "Сырые строки" - можно писать регулярные выражения просто так, без слэшей
- Правые строки - можно не ставить пробел после скобки > перед скобкой >
- SFNAE rule (Substitution Fail Is Not An Error) - если тип данных в классе ещё не определён, то это не ошибка
- Static assertion - проверка верности функционирования программы
- Псевдонимы шаблонов
- Единый синтаксис инициализации и семантика - инициализируем в фигурных скобочках
- Пользовательские литералы (auto d = 123.5 km;)
- Шаблоны с переменным числом параметров
	Пример: template <typename T, ...>
	T function(...)