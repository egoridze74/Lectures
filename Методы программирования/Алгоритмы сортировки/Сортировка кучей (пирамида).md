#методы_проги 
"Пирамида" - куча, в которой элементы заполняются по уровням и слева направо. И каждый потомок - меньше или равен родителю.

Интересные факты:
1) Кучу легко упаковать массив, а массив отобразить в кучу
2) Половина всех узлов - листы (узлы без детей)

### Идея
Идем по элементам с конца (самого правого элемента нижнего уровня) и рекурсивно меняем элемент с потомком, если элемент меньше, чем потомок.

Тем самым, мы построили пирамиду. Это называется процедурой просеивания. Для одного элемента процедура просеивания имеет сложность $O(\log_2 n)$

Дальше поступаем так: идем от максимума, свапаем элемент с последним и отрезаем его. А дальше просеиваем тот элемент, который мы заменили.

Считаем сложность:
- За первый раунд просеивания сделали $\frac{n}{2} \cdot \log_2 n$ действий (просеяили все элементы, кроме листьев)
- За второй раунд (свап и просеивание) сделали $n \cdot \log_2 n$ действий
- В итоге получили сложность $n \cdot \log_2 n$

### Алгоритм
Написать функцию для просеивания (downHeap) и потом юзануть эту функцию сначала для половины элементов, а потом второй раунд

### Реализация
``` python
def downHeap(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    
    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right
        
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        downHeap(arr, n, largest)

def heapsort(arr):
    n = len(arr)
    
    for i in range(n // 2 - 1, -1, -1):
        downHeap(arr, n, i)
        
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        downHeap(arr, i, 0)
```

### Анализ
1. Алгоритмическая сложность: $O(n \cdot \log_2 n)$
2. Дополнительные затраты по памяти: $O(1)$
3. Устойчивость: нет (из-за второго раунда свапа и структуры кучи)
4. Естественность поведения: нет