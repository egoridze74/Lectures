#методы_проги 
### Идея
"Разделяй и властвуй". Выбираем "опорный" элемент в массиве, а затем идем, например, слева направо и ищем элемент, который больше или равен опорного, запоминаем его. Затем идем справа налево и ищем элемент, который меньше или равен опорного, тоже запоминаем. И меняем элементы, которые запомнили, местами. Если вдруг индексы перекрестились, то ничего не делаем и перестаем повторять эту операцию. 

Получается, мы разделили массив на 2 части относительно опорного элемента.

Затем разбираемся с каждой из частей по тому же принципу: выбираем опорный элемент и крутим элементы вокруг него. Таким образом мы дойдем до того, что "часть" будет состоять из 1 элемента. На этом и заканчиваем.

### Алгоритм
1. Выбираем опорный элемент `pivot` (например, средний).
2. Устанавливаем два указателя: `i` (начало), `j` (конец).
3. Двигаем `i` вправо, пока не найдем элемент `arr[i] >= pivot`.
4. Двигаем `j` влево, пока не найдем элемент `arr[j] <= pivot`.
5. Если `i <= j`, меняем `arr[i]` и `arr[j]` местами, сдвигаем `i++`, `j--`.
6. Повторяем шаги 3-5, пока `i <= j`.
7. Рекурсивно применяем алгоритм к левой (`left`, `j`) и правой (`i`, `right`) частям

### Реализация
```
def quicksort(arr, left, right):
    if left < right:
        pivot = arr[(left + right) // 2]
        i = left
        j = right
        
        while i <= j:
            while arr[i] < pivot:
                i += 1
            while arr[j] > pivot:
                j -= 1
            if i <= j:
                arr[i], arr[j] = arr[j], arr[i]
                i += 1
                j -= 1
                
        quicksort(arr, left, j)
        quicksort(arr, i, right)
```

### Анализ
1. Алгоритмическая сложность: $O(n * \log_2 n)$
2. Дополнительные затраты по памяти: $O(\log_2 n)$ для стека рекурсии. Можно добить до константы
3. Устойчивость: нет
4. Естественность поведения: нет